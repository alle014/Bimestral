<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Labirinto com Vitória</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #eee;
    }
    canvas {
      background-color: #fff;
      border: 2px solid #000;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    // --------------------------
    // 1. Labirinto (1 = parede, 0 = caminho livre, 2 = saída)
    // --------------------------
    const maze = [
      [1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,1,0,0,0,0,0,0,1],
      [1,0,1,0,1,0,1,1,1,1,0,1],
      [1,0,1,0,0,0,0,0,0,1,0,1],
      [1,0,1,1,1,1,1,1,0,1,0,1],
      [1,0,0,0,0,0,0,1,0,1,0,1],
      [1,1,1,1,1,1,0,1,0,1,0,1],
      [1,0,0,0,0,1,0,0,0,1,0,1],
      [1,0,1,1,0,1,1,1,0,1,0,1],
      [1,0,0,1,0,0,0,1,0,0,0,2], // saída (2) no canto direito
      [1,1,0,1,1,1,0,1,1,1,1,1],
      [1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // --------------------------
    // 2. Canvas e variáveis
    // --------------------------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const rows = maze.length;
    const cols = maze[0].length;

    const canvasSize = 500;
    canvas.width = canvasSize;
    canvas.height = canvasSize;

    const cellSize = canvasSize / cols;

    // --------------------------
    // 3. Player
    // --------------------------
    let player = { row: 1, col: 1 };

    function drawPlayer() {
      ctx.fillStyle = 'blue';
      ctx.fillRect(
        player.col * cellSize + 2, 
        player.row * cellSize + 2, 
        cellSize - 4, 
        cellSize - 4
      );
    }

    // --------------------------
    // 4. Inimigo
    // --------------------------
    let enemy = { row: 1, col: 10 };
    let playerMoved = false;
    let enemyPath = [];
    let lastPlayerPosition = { row: player.row, col: player.col };

    function drawEnemy() {
      ctx.fillStyle = 'red';
      ctx.fillRect(
        enemy.col * cellSize + 2, 
        enemy.row * cellSize + 2, 
        cellSize - 4, 
        cellSize - 4
      );
    }

    // Algoritmo A* simplificado para encontrar caminho
    function findPath(start, end) {
      const openSet = [start];
      const cameFrom = {};
      const gScore = {};
      const fScore = {};
      
      const key = pos => `${pos.row},${pos.col}`;
      gScore[key(start)] = 0;
      fScore[key(start)] = heuristic(start, end);
      
      while (openSet.length > 0) {
        // Ordena pelo menor fScore
        openSet.sort((a, b) => (fScore[key(a)] || Infinity) - (fScore[key(b)] || Infinity));
        const current = openSet.shift();
        
        if (current.row === end.row && current.col === end.col) {
          // Reconstruir o caminho
          const path = [current];
          while (cameFrom[key(path[0])]) {
            path.unshift(cameFrom[key(path[0])]);
          }
          return path.slice(1); // Remove a posição atual
        }
        
        const neighbors = [
          {row: current.row - 1, col: current.col},
          {row: current.row + 1, col: current.col},
          {row: current.row, col: current.col - 1},
          {row: current.row, col: current.col + 1}
        ].filter(pos => 
          pos.row >= 0 && pos.row < rows &&
          pos.col >= 0 && pos.col < cols &&
          maze[pos.row][pos.col] !== 1
        );
        
        for (const neighbor of neighbors) {
          const tentativeGScore = (gScore[key(current)] || 0) + 1;
          if (tentativeGScore < (gScore[key(neighbor)] || Infinity)) {
            cameFrom[key(neighbor)] = current;
            gScore[key(neighbor)] = tentativeGScore;
            fScore[key(neighbor)] = gScore[key(neighbor)] + heuristic(neighbor, end);
            if (!openSet.some(p => p.row === neighbor.row && p.col === neighbor.col)) {
              openSet.push(neighbor);
            }
          }
        }
      }
      
      return []; // Nenhum caminho encontrado
    }
    
    function heuristic(a, b) {
      // Distância de Manhattan
      return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
    }

    function moveEnemy() {
      // Só recalcula o caminho se o player se moveu
      if (player.row !== lastPlayerPosition.row || player.col !== lastPlayerPosition.col) {
        enemyPath = findPath(enemy, player);
        lastPlayerPosition = { row: player.row, col: player.col };
      }
      
      if (enemyPath.length > 0) {
        // Move para o próximo passo no caminho
        const nextStep = enemyPath[0];
        enemy.row = nextStep.row;
        enemy.col = nextStep.col;
        enemyPath.shift();
      } else {
        // Se não há caminho, tenta se aproximar
        const directions = [
          {row: enemy.row - 1, col: enemy.col},
          {row: enemy.row + 1, col: enemy.col},
          {row: enemy.row, col: enemy.col - 1},
          {row: enemy.row, col: enemy.col + 1}
        ].filter(pos =>
          pos.row >= 0 && pos.row < rows &&
          pos.col >= 0 && pos.col < cols &&
          maze[pos.row][pos.col] !== 1
        );
        
        if (directions.length > 0) {
          // Escolhe a direção que mais aproxima do player
          directions.sort((a, b) => 
            heuristic(a, player) - heuristic(b, player)
          );
          enemy.row = directions[0].row;
          enemy.col = directions[0].col;
        }
      }
    }

    // --------------------------
    // 5. Labirinto
    // --------------------------
    function drawMaze() {
      for(let row = 0; row < rows; row++) {
        for(let col = 0; col < cols; col++) {
          if(maze[row][col] === 1) {
            ctx.fillStyle = 'black'; // parede
          } else if(maze[row][col] === 2) {
            ctx.fillStyle = 'green'; // saída
          } else {
            ctx.fillStyle = 'white'; // caminho
          }
          ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
          ctx.strokeStyle = 'gray';
          ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }
      }
    }

    // --------------------------
    // 6. Game Loop (desenha tudo)
    // --------------------------
    function draw() {
      drawMaze();
      drawPlayer();
      drawEnemy();
    }

    // --------------------------
    // 7. Movimentação do Player
    // --------------------------
    window.addEventListener('keydown', function(e) {
      let newRow = player.row;
      let newCol = player.col;

      if(e.key === 'w' || e.key === 'ArrowUp') newRow--;
      else if(e.key === 's' || e.key === 'ArrowDown') newRow++;
      else if(e.key === 'a' || e.key === 'ArrowLeft') newCol--;
      else if(e.key === 'd' || e.key === 'ArrowRight') newCol++;
      else return;

      if(newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
        if(maze[newRow][newCol] !== 1) { // pode andar em 0 (caminho) ou 2 (saída)
          player.row = newRow;
          player.col = newCol;
          if(!playerMoved) playerMoved = true;
          checkVictory();
          draw();
        }
      }
    });

    // --------------------------
    // 8. Condições de vitória e derrota
    // --------------------------
    function checkGameOver() {
      if(player.row === enemy.row && player.col === enemy.col) {
        alert('Game Over! O inimigo te pegou.');
        resetGame();
      }
    }

    function checkVictory() {
      if(maze[player.row][player.col] === 2) {
        alert('Você venceu!');
        resetGame();
      }
    }

    function resetGame() {
      player = { row: 1, col: 1 };
      enemy = { row: 1, col: 10 };
      playerMoved = false;
      enemyPath = [];
      lastPlayerPosition = { row: player.row, col: player.col };
      draw();
    }

    // --------------------------
    // 9. Movimento do inimigo automático
    // --------------------------
    setInterval(() => {
      if(playerMoved) {
        moveEnemy();
        draw();
        checkGameOver();
      }
    }, 300); // Velocidade um pouco mais rápida

    // --------------------------
    // 10. Inicialização
    // --------------------------
    draw();
  </script>
</body>
</html>
